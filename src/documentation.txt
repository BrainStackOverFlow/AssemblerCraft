documentation:

the registers are in the size of 32 bits

processor core:
	registers:
		res1:
			also known as 'r0'.
			will strore the results of instructions
		res2:
			also known as 'r1'.
			will strore the secondary results of instructions
		src1:
			also known as 'r2'.
			will strore the operand needed for instructions
		src2
			also known as 'r3'.
			will strore the secondary operand needed for instructions
		dr1
		dr2
		dr3
		dr4:
			they are the data registers, they are storing data also known as r4-7
		sp:
			the stack register, also known as 'r8'
			points to the top of the stack
		bp:
			the stack base register, also known as 'r9'
		flags:
			the flags register, also known as 'r10'
			contain the flollowing flags:	
		ip:
			the instruction pointer register, also known as 'r11'
			contain the pointer for the next instruction that will be executed

instruction:
	nop:
		opcode: none
		modified: none
		parameters: none
		additional operands (in instruction memory): none
		notes: none
	add:
		opcode:
		modified: 
			registers: res1 
		parameters:
			registers: src1, src2
		additional operands (in instruction memory):
			none
		notes:
			does addition on the src1 and src2 registers, store the result in res1
	sub:
		opcode:
		modified: 
			registers: res1 
		parameters:
			registers: src1, src2
		additional operands (in instruction memory):
			none
		notes:
			does substraction on the src1 and src2 registers, store the result in res1
	umul
		opcode:
		modified: 
			registers: res1, res2
		parameters:
			registers: src1, src2
		additional operands (in instruction memory):
			none
		notes:
			does unsigned integer multiplication on the src1 and src2 registers
			the instructions store the result lower-order bits (bits 0-31) in res1, and the result high-order (bits 31-63) bits in res2
	udiv:
		opcode:
		modified: 
			registers: res1, res2
		parameters:
			registers: src1, src2
		additional operands (in instruction memory):
			none
		notes:
			does unsigned integer division on the src1 and src2 registers
			the instructions store the result  in res1, and the reminder in res2
	smul:
		opcode:
		modified: 
			registers: res1, res2
		parameters:
			registers: src1, src2
		additional operands (in instruction memory):
			none
		notes:
			does signed integer multiplication on the src1 and src2 registers
			the instructions store the result lower-order bits (bits 0-31) in res1, and the result high-order (bits 31-63) bits in res2
	sdiv:
		opcode:
		modified: 
			registers: res1, res2
		parameters:
			registers: src1, src2
		additional operands (in instruction memory):
			none
		notes:
			does signed integer division on the src1 and src2 registers
			the instructions store the result  in res1, and the reminder in res2
	neg:
		opcode:
		modified: 
			registers: res1
		parameters:
			registers: src1
		additional operands (in instruction memory):
			none
		notes:
			make the number negative to what he was before in the two's complement system.
		
	fadd:
		opcode: 
		modified: 
			registers: res1
		parameters:
			registers: src1, src2
		additional operands (in instruction memory):
			none
		notes: 
			floating point addition
	fsub:
		opcode: 
		modified: 
			registers: res1
		parameters:
			registers: src1, src2
		additional operands (in instruction memory):
			none
		notes: 
			floating point substraction
	fmul:
		opcode: 
		modified: 
			registers: res1
		parameters:
			registers: src1, src2
		additional operands (in instruction memory):
			none
		notes: 
			floating point multiplication
	fdiv:
		opcode: 
		modified: 
			registers: res1
		parameters:
			registers: src1, src2
		additional operands (in instruction memory):
			none
		notes: 
			floating point division
	fpow:
		opcode: 
		modified: 
			registers: res1
		parameters:
			registers: src1, src2
		additional operands (in instruction memory):
			none
		notes: 
			floating point exponentiation.
			src1 is the base, and src2 is the exponent
	frot:
		opcode: 
		modified: 
			registers: res1
		parameters:
			registers: src1, src2
		additional operands (in instruction memory):
			none
		notes: 
			floating point root.
			src1 is the radicand, and src2 is the degree
	fabs:
		opcode: 
		modified: 
			registers: res1
		parameters:
			registers: src1
		additional operands (in instruction memory):
			none
		notes: 
			floating point absolute value
	fsin:
		opcode: 
		modified: 
			registers: res1
		parameters:
			registers: src1
		additional operands (in instruction memory):
			none
		notes: 
			calculate the sine() of the src1 register. the result is floating point
	fcos:
		opcode: 
		modified: 
			registers: res1
		parameters:
			registers: src1
		additional operands (in instruction memory):
			none
		notes: 
			calculate the cosine() of the src1 register. the result is floating point
	flog:
		opcode: 
		modified: 
			registers: res1
		parameters:
			registers: src1, src2
		additional operands (in instruction memory):
			none
		notes: 
			floating point logarithm.
			src1 is the anti-logarithm, and src2 is base
	
	itf:
		opcode: 
		modified: 
			registers: res1
		parameters:
			registers: src1
		additional operands (in instruction memory):
			none
		notes: 
			int to float
			
	fti:
		opcode: 
		modified: 
			registers: res1
		parameters:
			registers: src1
		additional operands (in instruction memory):
			none
		notes: 
			float to int
	
	not:
		opcode:
		modified: 
			registers: res1 
		parameters:
			registers: src1
		additional operands (in instruction memory):
			none
		notes:
			does not on the src1 register, store the result in res1
	or:
		opcode:
		modified: 
			registers: res1 
		parameters:
			registers: src1, src2
		additional operands (in instruction memory):
			none
		notes:
			does or on the src1 and src2 registers, store the result in res1
	and:
		opcode:
		modified: 
			registers: res1 
		parameters:
			registers: src1, src2
		additional operands (in instruction memory):
			none
		notes:
			does and on the src1 and src2 registers, store the result in res1
	xor:
		opcode:
		modified: 
			registers: res1 
		parameters:
			registers: src1, src2
		additional operands (in instruction memory):
			none
		notes:
			does xor on the src1 and src2 registers, store the result in res1
	
	loadmb:
		load to memory byte
		src1 is the pointer to memory
		src2 is the value that would be uploaded
	loadmd:
		load to memory double byte (2 bytes, 16 bits)
		src1 is the pointer to memory
		src2 is the value that would be uploaded
	loadmq:
		load to memory double byte (4 bytes, 32 bits)
		src1 is the pointer to memory
		src2 is the value that would be uploaded
	loadr:
		load from memory to register
		src1 pointer to memory
		res1 have 4 bytes value from that pointer
		if u want only part of the values u can `and` the with the result
	mov:
		move values from registers to another registers
		in memory, after the opcode comes another 2 bytes that are related to this command, these are the operand
		the first operand states the destination register, and the second states the source register
	set:
		sets registers with a constant operand
		have extra 5 bytes after it.
		the first byte states what register will be set
		and the other 2-5 bytes (4) states the value that the register will be setted to.
	swap:
		swap registers values
		have 2 extra bytes that determines the swapped registers
	
	push:
		pushes a register to the stack
		the register is determined by the next byte
	pop:
		pop a register from the stack
		the register is determined by the next byte
		
	save:
		pushes all the registers to the stack to save them
	rest:
		pop all the registers from the stack to restore them
	
	jmp:
		
	call:
		pushes the ip regsiter to the stack, and then does the jmp instruction
	ret:
		pop to the ip register from the stack
	int:
		interrupt
	
	in:
		src1 is the input port
		res1 will have the value from the port
	out:
		src1 is the output port
		src2 is the value
		
	cpuid:
		