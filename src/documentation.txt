documentation:

byte = 1 byte
double byte = 2 bytes
quad byte = 4 bytes

the size of an instruction is 16 bits
the registers are in the size of 32 bits

processor core:
	registers:
		res1:
			also known as 'r0'.
			will strore the results of instructions
		res2:
			also known as 'r1'.
			will strore the secondary results of instructions
		src1:
			also known as 'r2'.
			will strore the operand needed for instructions
		src2
			also known as 'r3'.
			will strore the secondary operand needed for instructions
		dr1
		dr2
		dr3
		dr4:
			they are the data registers, they are storing data also known as r4-7
		sp:
			the stack register, also known as 'r8'
			points to the top of the stack
		bp:
			the stack base register, also known as 'r9'
		flags:
			the flags register, also known as 'r10'
			contain the flollowing flags:
				FF : false Flag
					its value is always 0
				TF : True Flag 
					its value is always 1
				ZF : Zero Flag
				SF : Sign Flag
				CF : Carry Flag
				OF : Overflow Flag
				CB : Control Bit
					determine the control flow of the program, if disabled the next instruction will not execute:
						jmpa, jmpr, jmp
		ip:
			the instruction pointer register, also known as 'r11'
			contain the pointer for the next instruction that will be executed
		

instruction:
	nop:
		opcode: 
		parameters: none
		modifies: none
		notes: the instruction does nothing.
	add:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1 
		notes:
			the instruction does an integer addition on the src1 and src2 registers, and store the result in res1.
			res1 = src1 + src2
	sub:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1 
		notes:
			the instruction does an integer substraction on the src1 and src2 registers, and store the result in res1.
			res1 = src1 - src2
	umul
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1 
		notes:
			the instruction does an unsigned integer multiplication on the src1 and src2 registers, and store the result in res1.
			res1 = src1 * src2
	udiv:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1 
		notes:
			the instruction does an unsigned integer division on the src1 and src2 registers, and store the result in res1 and the reminder in res2.
			res1 = src1 / src2
			res2 = src1 - src2 * res1
	smul:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1 
		notes:
			the instruction does a signed integer multiplication on the src1 and src2 registers, and store the result in res1.
			res1 = src1 * src2
	sdiv:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1 
		notes:
			the instruction does a signed integer division on the src1 and src2 registers, and store the result in res1 and the reminder in res2.
			res1 = src1 / src2
			res2 = src1 - src2 * res1
	neg:
		opcode:
		parameters:
			registers: byte r
		modifies: 
			registers: r
		notes:
			make register r value negative in the two's complement system.	
			r = -r
	fadd:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1
		notes:
			the instruction does an floating point addition on the src1 and src2 registers, and store the result in res1.
			res1 = src1 + src2
	fsub:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1
		notes:
			the instruction does an floating point substraction on the src1 and src2 registers, and store the result in res1.
			res1 = src1 - src2
	fmul:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1 
		notes:
			the instruction does a floating point multiplication on the src1 and src2 registers, and store the result in res1.
			res1 = src1 * src2
	fdiv:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1 
		notes:
			the instruction does a floating point division on the src1 and src2 registers, and store the result in res1.
			res1 = src1 / src2
	fpow:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1 
		notes:
			the instruction does a floating point exponentiation on the src1 and src2 registers, and store the result in res1.
			res1 = src1 ^ src2	(the "^" doesnt represent xor)	
			src1 is the base, and src2 is the exponent
	fabs:
		opcode:
		parameters:
			registers: byte r
		modifies: 
			registers: r
		notes:
			the instruction does a floating point absolute value on register r
	fsin:
		opcode:
		parameters:
			registers: src1
		modifies: 
			registers: res1, res2
		notes: 
			the instruction does a floating point sine and cosine on the src1 registers, and store the result in res1 and res2.
			res1 = sine(src1)
			res2 = cosine(src1)
	flog:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1
		notes: 
			the instruction does a floating point logarithm on the src1 and src2 registers, and store the result in res1.
			res1 = logsrc2(src1)
			src1 is the anti-logarithm, and src2 is base
	itf:
		opcode:
		parameters:
			registers: byte r
		modifies: 
			registers: r
		notes:
			the instruction convert register r value from int to float.				
	fti:
		opcode:
		parameters:
			registers: byte r
		modifies: 
			registers: r
		notes:
			the instruction convert register r value from float to int
	not:
		opcode:
		parameters:
			registers: byte r
		modifies: 
			registers: r
		notes:
			the instruction flips all register bits.
			r = ~r
	or:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1
		notes: 
			the instruction does an bitwise or operation on the src1 and src2 registers, and store the result in res1.
			res1 = src1 | src2
	and:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1
		notes: 
			the instruction does an bitwise and operation on the src1 and src2 registers, and store the result in res1.
			res1 = src1 & src2
	xor:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1
		notes: 
			the instruction does an bitwise xor operation on the src1 and src2 registers, and store the result in res1.
			res1 = src1 ^ src2
	memb:
		opcode:
		parameters:
			registers: byte a, byte b
		modifies: 
			memory: [a]
		notes: 
			MEMory load Byte 
			src1 is the pointer to memory
			src2 is the value that would be loaded
			[a] = (uint8_t)b
	memd:
		opcode:
		parameters:
			registers: byte a, byte b
		modifies: 
			memory: [a]
		notes: 
			MEMory load Double byte 	
			src1 is the pointer to memory
			src2 is the value that would be loaded
			[a] = (uint16_t)b
	memq:
		opcode:
		parameters:
			registers: byte a, byte b
		modifies: 
			memory: [a]
		notes: 
			MEMory load Quad byte 	
			src1 is the pointer to memory
			src2 is the value that would be loaded
			[a] = (uint32_t)b
	load:
		opcode:
		parameters:
			registers: byte a, byte b
		modifies: 
			registers: b
		notes: 
		b = [a]
	mov:
		opcode:
		parameters:
			registers: byte a, byte b
		modifies: 
			registers: a
		notes:
			the instruction MOVe the value of register b to register a
			reg a = reg b
	set:
		opcode:
		parameters:
			registers: byte r, quad byte val
		modifies: 
			registers: r
		notes:
			the instruction SETs register r with the constant operand val
			reg r = val
	swap:
		opcode:
		parameters:
			registers: byte a, byte b
		modifies: 
			registers: a, b
		notes:
			the instruction SWAP the values of registers a and b
	push:
		parameters:
			registers: r
		modifies: 
			registers: sp
			memory: [sp]
		notes:
			the instruction pushes register r to the stack
			sp = sp - 4
			[sp] = r
	pop:
		parameters:
			registers: r
		modifies: 
			registers: sp, r
		notes:
			the instruction pop to register r from the stack
			r = [sp]
			sp = sp + 4
		
	save:
		pushes all the registers to the stack to save them
	rest:
		pop all the registers from the stack to restore them
	jmpa:
		parameters:
			memory: quad byte x
		modifies: 
			registers: ip
		notes:
			the instruction does an absoulte jump, its sets the value of ip register to x.
			ip = x
	jmpr:
		parameters:
			memory: quad byte x
		modifies: 
			registers: ip
		notes:
			the instruction does a relative jump, its adds the value fo x to the ip register.
			ip = ip + x
	jmp:
		parameters:
			memory: byte r
		modifies: 
			registers: ip
		notes:
			the instruction does an absolute jump, its sets the value of ip register to the value of the r regsiter.
			ip = reg r
	call:
		parameters:
			memory: quad byte x
		modifies: 
			memory [sp - 4]
			registers: sp, ip
		notes:
			the instruction push the ip register to the stack and then change the ip register value to x
			its the same like doing: (if assuming the CB is true)
				push ip
				jmpa x
	calr:
		call:
		parameters:
			memory: byte r
		modifies: 
			memory [sp - 4]
			registers: sp, ip
		notes:
			the instruction push the ip register to the stack and then change the ip register value to x
			its the same like doing: if assuming the CB is true)
				push ip
				jmp r
	ret:
		call:
		parameters:
			memory: byte x, [sp]
		modifies: 
			registers: ip, sp
		notes:
			the instruction pop to the ip register from the stack, and then releases x bytes from the stack.
			same as doing:
				pop ip
				sp = sp + x
	int:
		interrupt
	
	in:
		src1 is the input port
		res1 will have the value from the port
	out:
		src1 is the output port
		src2 is the value
		
	cpuid:
		