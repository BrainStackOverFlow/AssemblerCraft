documentation:

byte = 1 byte
double byte = 2 bytes
quad byte = 4 bytes

the size of an instruction is 16 bits
the registers are in the size of 32 bits

processor core:
	registers:
		res1:
			also known as 'r0'.
			will strore the results of instructions
		res2:
			also known as 'r1'.
			will strore the secondary results of instructions
		src1:
			also known as 'r2'.
			will strore the operand needed for instructions
		src2
			also known as 'r3'.
			will strore the secondary operand needed for instructions
		dr1
		dr2
		dr3
		dr4:
			they are the data registers, they are storing data also known as r4-7
		sp:
			the stack register, also known as 'r8'
			points to the top of the stack
		bp:
			the stack base register, also known as 'r9'
		flags:
			the flags register, also known as 'r10'
			contain the flollowing flags:
				FF : false Flag
					its value is always 0
				TF : True Flag 
					its value is always 1
				ZF : Zero Flag
				SF : Sign Flag
				CF : Carry Flag
				OF : Overflow Flag
				CB : Control Bit
					detemines if a some instruction will appen or notjmp/
		ip:
			the instruction pointer register, also known as 'r11'
			contain the pointer for the next instruction that will be executed
		

instruction:
	nop:
		opcode: 
		parameters: none
		modifies: none
		notes: the instruction does nothing.
	add:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1 
		notes:
			the instruction does an integer addition on the src1 and src2 registers, and store the result in res1.
			res1 = src1 + src2
	sub:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1 
		notes:
			the instruction does an integer substraction on the src1 and src2 registers, and store the result in res1.
			res1 = src1 - src2
	umul
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1 
		notes:
			the instruction does an unsigned integer multiplication on the src1 and src2 registers, and store the result in res1.
			res1 = src1 * src2
	udiv:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1 
		notes:
			the instruction does an unsigned integer division on the src1 and src2 registers, and store the result in res1 and the reminder in res2.
			res1 = src1 / src2
			res2 = src1 - src2 * res1
	smul:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1 
		notes:
			the instruction does a signed integer multiplication on the src1 and src2 registers, and store the result in res1.
			res1 = src1 * src2
	sdiv:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1 
		notes:
			the instruction does a signed integer division on the src1 and src2 registers, and store the result in res1 and the reminder in res2.
			res1 = src1 / src2
			res2 = src1 - src2 * res1
	neg:
		opcode:
		parameters:
			registers: byte r
		modifies: 
			registers: r
		notes:
			make register r value negative in the two's complement system.	
			r = -r
	fadd:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1
		notes:
			the instruction does an floating point addition on the src1 and src2 registers, and store the result in res1.
			res1 = src1 + src2
	fsub:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1
		notes:
			the instruction does an floating point substraction on the src1 and src2 registers, and store the result in res1.
			res1 = src1 - src2
	fmul:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1 
		notes:
			the instruction does a floating point multiplication on the src1 and src2 registers, and store the result in res1.
			res1 = src1 * src2
	fdiv:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1 
		notes:
			the instruction does a floating point division on the src1 and src2 registers, and store the result in res1.
			res1 = src1 / src2
	fpow:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1 
		notes:
			the instruction does a floating point exponentiation on the src1 and src2 registers, and store the result in res1.
			res1 = src1 ^ src2	(the "^" doesnt represent xor)	
			src1 is the base, and src2 is the exponent
	fabs:
		opcode:
		parameters:
			registers: byte r
		modifies: 
			registers: r
		notes:
			the instruction does a floating point absolute value on register r
	fsin:
		opcode:
		parameters:
			registers: src1
		modifies: 
			registers: res1, res2
		notes: 
			the instruction does a floating point sine and cosine on the src1 registers, and store the result in res1 and res2.
			res1 = sine(src1)
			res2 = cosine(src1)
	flog:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1
		notes: 
			the instruction does a floating point logarithm on the src1 and src2 registers, and store the result in res1.
			res1 = logsrc2(src1)
			src1 is the anti-logarithm, and src2 is base
	itf:
		opcode:
		parameters:
			registers: byte r
		modifies: 
			registers: r
		notes:
			the instruction convert register r value from int to float.				
	fti:
		opcode:
		parameters:
			registers: byte r
		modifies: 
			registers: r
		notes:
			the instruction convert register r value from float to int
	not:
		opcode:
		parameters:
			registers: byte r
		modifies: 
			registers: r
		notes:
			the instruction flips all register bits.
	or:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1
		notes: 
			the instruction does an bitwise or operation on the src1 and src2 registers, and store the result in res1.
			res1 = src1 | src2
	and:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1
		notes: 
			the instruction does an bitwise and operation on the src1 and src2 registers, and store the result in res1.
			res1 = src1 & src2
	xor:
		opcode:
		parameters:
			registers: src1, src2
		modifies: 
			registers: res1
		notes: 
			the instruction does an bitwise xor operation on the src1 and src2 registers, and store the result in res1.
			res1 = src1 ^ src2
	memb:
		opcode:
		parameters:
			registers: byte a, byte b
		modifies: 
			registers: [a]
		notes: 
			MEMory load Byte 
			src1 is the pointer to memory
			src2 is the value that would be loaded
			[a] = (uint8_t)b
	memd:
		opcode:
		parameters:
			registers: byte a, byte b
		modifies: 
			registers: [a]
		notes: 
			MEMory load Double byte 	
			src1 is the pointer to memory
			src2 is the value that would be loaded
			[a] = (uint16_t)b
	memq:
		opcode:
		parameters:
			registers: byte a, byte b
		modifies: 
			registers: [a]
		notes: 
			MEMory load Quad byte 	
			src1 is the pointer to memory
			src2 is the value that would be loaded
			[a] = (uint32_t)b
	loadr:
		load from memory to register
		src1 pointer to memory
		res1 have 4 bytes value from that pointer
		if u want only part of the values u can `and` the with the result
	mov:
		opcode:
		parameters:
			registers: byte a, byte b
		modifies: 
			registers: a
		notes:
			the instruction MOVe the value of register b to register a
			reg a = reg b
	set:
		opcode:
		parameters:
			registers: byte r, quad byte val
		modifies: 
			registers: r
		notes:
			the instruction SETs register r with the constant operand val
			reg r = val
	swap:
		opcode:
		parameters:
			registers: byte a, byte b
		modifies: 
			registers: a, b
		notes:
			the instruction SWAP the values of registers a and b
	push:
		pushes a register to the stack
		the register is determined by the next byte
	pop:
		pop a register from the stack
		the register is determined by the next byte
		
	save:
		pushes all the registers to the stack to save them
	rest:
		pop all the registers from the stack to restore them
	
	jmp:
		
	call:
		pushes the ip regsiter to the stack, and then does the jmp instruction
	ret:
		pop to the ip register from the stack
	int:
		interrupt
	
	in:
		src1 is the input port
		res1 will have the value from the port
	out:
		src1 is the output port
		src2 is the value
		
	cpuid:
		