documentation:

byte = 1 byte
double byte = 2 bytes
quad byte = 4 bytes

the size of an instruction is 16 bits
the registers are in the size of 32 bits

processor core:
	registers:
		r0-r7:
			general purpose registers
		sp:
			the stack register, also known as 'r8'
			points to the top of the stack
		bp:
			the stack base register, also known as 'r9'
		flags:
			the flags register, also known as 'r10'
			contain the flollowing flags:
				CB : Control Bit
					determine the control flow of the program, if disabled the next instruction will skipped:
						jmpa, jmpr
				ZF : Zero Flag
				SF : Sign Flag
				CF : Carry Flag
				OF : Overflow Flag
				
		ip:
			the instruction pointer register, also known as 'r11'
			contain the pointer for the next instruction that will be executed
		
		nullreg:
			the null reigster, nullifies all output that goes into it
	all registers are the size of quad byte

instructions:
	all of the instructions opcodes are size 2 bytes (16 bits)
	instructions may have additional data
	
	nop:
		opcode: 
		parameters: none
		modifies: none
		notes: the instruction does nothing.
	add:
		opcode:
		parameters:
			in instruction memory: 
				byte dest: a number between 0-256 which specify which register will keep the result of the operation
				byte src1, src2: numbers between 0-256 which specify the registers to take the paramaters for the operation
		modifies: 
			registers: reg(dest)
		notes:
			the instruction does an integer addition on the src1 and src2 registers, and store the result in dest.
			dest = res1 + res2
	sub:
		opcode:
		parameters:
			in instruction memory: 
				byte dest: a number between 0-256 which specify which register will keep the result of the operation
				byte src1, src2: numbers between 0-256 which specify the registers to take the paramaters for the operation
		modifies: 
			registers: reg(dest) 
		notes:
			the instruction does an integer substraction on the src1 and src2 registers, and store the result in dest.
			dest = src1 - src2
	umul
		opcode:
		parameters:
			in instruction memory: 
				byte dest1, dest2: a number between 0-256 which specify which registerS will keep the result of the operation
				byte src1, src2: numbers between 0-256 which specify the registers to take the paramaters for operation
		modifies: 
			registers: 
				reg(dest1)
				reg(dest2)
		notes:
			the instruction does an unsigned integer multiplication on the src1 and src2 registers, and store the result in dest1:dest2.
			keeps the most significant part of the result in dest2
			dest1:dest2 = src1 * src2
	udiv:
		opcode:
		parameters:
			in instruction memory: 
				byte dest1, dest2: a number between 0-256 which specify which registerS will keep the result of the operation
				byte src1, src2: numbers between 0-256 which specify the registers to take the paramaters for operation
		modifies: 
			registers: 
				reg(dest1)
				reg(dest2)
		notes:
			the instruction does an unsigned integer division on the src1 and src2 registers, and store the result in dest1 and the reminder in dest2.
			dest = src1 / src2
			res2 = src1 - src2 * res1
	smul:
		opcode:
		parameters:
			in instruction memory: 
				byte dest1, dest2: a number between 0-256 which specify which registerS will keep the result of the operation
				byte src1, src2: numbers between 0-256 which specify the registers to take the paramaters for operation
		modifies: 
			registers: 
				reg(dest1)
				reg(dest2)
		notes:
			the instruction does a signed integer multiplication on the src1 and src2 registers, and store the result in dest1:dest2.
			keeps the most significant part of the result in dest2
			res1 = src1 * src2
	sdiv:
		opcode:
		parameters:
			in instruction memory: 
				byte dest1, dest2: a number between 0-256 which specify which registerS will keep the result of the operation
				byte src1, src2: numbers between 0-256 which specify the registers to take the paramaters for operation
		modifies: 
			registers: 
				reg(dest1)
				reg(dest2)
		notes:
			the instruction does an signed integer division on the src1 and src2 registers, and store the result in dest1 and the reminder in dest2.
			dest = src1 / src2
			res2 = src1 - src2 * res1
	neg:
		opcode:
		parameters:
			in instruction memory:
				byte r: specify which register to do the operation on
		modifies: 
			registers:
				reg(r)
		notes:
			make register r value negative in the two's complement system.	
			r = -r
	fadd:
		parameters:
			in instruction memory: 
				byte dest: a number between 0-256 which specify which register will keep the result of the operation
				byte src1, src2: numbers between 0-256 which specify the registers to take the paramaters for the operation
		modifies: 
			registers:
				reg(dest) 
		notes:
			the instruction does an floating point addition on the src1 and src2 registers, and store the result in dest.
			dest = res1 + res2
	fsub:
		opcode:
		parameters:
			in instruction memory: 
				byte dest: a number between 0-256 which specify which register will keep the result of the operation
				byte src1, src2: numbers between 0-256 which specify the registers to take the paramaters for the operation
		modifies: 
			registers: 
				reg(dest) 
		notes:
			the instruction does an floating point substraction on the src1 and src2 registers, and store the result in dest.
			dest = src1 - src2
	fmul:
		opcode:
		parameters:
			in instruction memory: 
				byte dest: a number between 0-256 which specify which register will keep the result of the operation
				byte src1, src2: numbers between 0-256 which specify the registers to take the paramaters for the operation
		modifies: 
			registers:
				reg(dest)
		notes:
			the instruction does a floating point multiplication on the src1 and src2 registers, and store the result in dest.
			dest = src1 * src2
	fdiv:
		opcode:
		parameters:
			in instruction memory: 
				byte dest: a number between 0-256 which specify which register will keep the result of the operation
				byte src1, src2: numbers between 0-256 which specify the registers to take the paramaters for the operation
		modifies: 
			registers: 
				reg(dest)
		notes:
			the instruction does a floating point division on the src1 and src2 registers, and store the result in dest.
			dest = src1 / src2
	fpow:
		opcode:
		parameters:
			in instruction memory: 
				byte dest: a number between 0-256 which specify which register will keep the result of the operation
				byte src1, src2: numbers between 0-256 which specify the registers to take the paramaters for the operation
		modifies: 
			registers: 
				reg(dest)
		notes:
			the instruction does a floating point exponentiation on the src1 and src2 registers, and store the result in dest.
			dest = src1 ^ src2	(the "^" doesnt represent xor)	
			src1 is the base, and src2 is the exponent
	fabs:
		opcode:
		parameters:
			in instruction memory:
				byte r: specify which register to do the operation on
		modifies: 
			registers: 
				reg(r)
		notes:
			the instruction does a floating point absolute value on register r
			r = |r|
	ftrig:
		opcode:
		paramaters:
			in instruction memory: 
				byte dest1, dest2: numbers between 0-256 which specify which registers will keep the results of the operation
				byte src: a number between 0-256 which specify the register to take the paramaters for the operation
		modifies: 
			registers:
				reg(dest1)
				reg(dest2)
		notes:
			does trigonometry functions on src1
			the instruction does a floating point sine and cosine on the src1 registers, and store the result in res1 and res2.
			dest1 = sine(src1)
			dest2 = cosine(src1)
	flog:
		opcode:
		parameters:
			in instruction memory: 
				byte dest: a number between 0-256 which specify which register will keep the result of the operation
				byte src1, src2: numbers between 0-256 which specify the registers to take the paramaters for the operation
		modifies: 
			registers:
				reg(dest)
		notes: 
			the instruction does a floating point logarithm on the src1 and src2 registers, and store the result in dest.
			dest = logsrc2(src1)
			src1 is the anti-logarithm, and src2 is base
	itf:
		opcode:
		parameters:
			in instruction memory:
				byte r: specify which register to do the operation on
		modifies: 
			registers: 
				reg(r)
		notes:
			the instruction convert register r value from int to float.				
	fti:
		opcode:
		parameters:
			in instruction memory:
				byte r: specify which register to do the operation on
		modifies: 
			registers: 
				reg(r)
		notes:
			the instruction convert register r value from float to int
	not:
		opcode:
		parameters:
			in instruction memory:
				byte r: specify which register to do the operation on
		modifies: 
			registers:
				reg(r)
		notes:
			the instruction flips all of the register bits.
			r = ~r
	or:
		opcode:
		parameters:
			in instruction memory: 
				byte dest: a number between 0-256 which specify which register will keep the result of the operation
				byte src1, src2: numbers between 0-256 which specify the registers to take the paramaters for the operation
		modifies: 
			registers:
				reg(dest)
		notes:
			the instruction does an bitwise or operation on the src1 and src2 registers, and store the result in dest.
			dest = src1 | src2
	and:
		opcode:
		parameters:
			in instruction memory: 
				byte dest: a number between 0-256 which specify which register will keep the result of the operation
				byte src1, src2: numbers between 0-256 which specify the registers to take the paramaters for the operation
		modifies: 
			registers:
				reg(dest)
		notes: 
			the instruction does an bitwise and operation on the src1 and src2 registers, and store the result in dest.
			dest = src1 & src2
	xor:
		opcode:
		parameters:
			in instruction memory: 
				byte dest: a number between 0-256 which specify which register will keep the result of the operation
				byte src1, src2: numbers between 0-256 which specify the registers to take the paramaters for the operation
		modifies: 
			registers:
				reg(dest)
		notes: 
			the instruction does an bitwise xor operation on the src1 and src2 registers, and store the result in dest.
			res1 = src1 ^ src2
	memb:
		opcode:
		parameters:
			in instruction memory: 
				byte dest: a number between 0-256 which specify which register holds the the pointer to memory
				byte val: a number between 0-256 which specify which register holds the value that would be loaded to memory
				quad byte offset
		modifies: 
			memory:
				[reg(dest) + offset]
		notes: 
			MEMory load Byte
			[reg(dest) + offset] = (uint8_t)reg(val)
	memd:
		opcode:
		parameters:
			in instruction memory: 
				byte dest: a number between 0-256 which specify which register holds the the pointer to memory
				byte val: a number between 0-256 which specify which register holds the value that would be loaded to memory
				quad byte offset
		modifies: 
			memory: 
				[reg(dest) + offset]
		notes: 
			MEMory load Double byte 	
			[reg(dest) + offset] = (uint16_t)reg(val)
	memq:
		opcode:
		parameters:
			in instruction memory: 
				byte dest: a number between 0-256 which specify which register holds the the pointer to memory
				byte val: a number between 0-256 which specify which register holds the value that would be loaded to memory
				quad byte offset
		modifies: 
			memory: 
				[reg(dest) + offset]
		notes: 
			MEMory load Quad byte 	
			[reg(dest) + offset] = (uint32_t)reg(val)
	ldb:
		opcode:
		parameters:
			in instruction memory: 
				byte dest: a number between 0-256 which specify which register will keep the result of the operation 
				byte src: a number between 0-256 which specify which register holds the the pointer to memory
				quad byte offset
		modifies: 
			registers:
				reg(dest)
		notes: 
			load byte from memory
			reg(dest) = (uint8_t)[reg(src) + offset]
	ldd:
		opcode:
		parameters:
			in instruction memory: 
				byte dest: a number between 0-256 which specify which register will keep the result of the operation 
				byte src: a number between 0-256 which specify which register holds the the pointer to memory
				quad byte offset
		modifies: 
			registers: 
				reg(dest)
		notes: 
			load double byte from memory
			reg(dest) = (uint16_t)[reg(src) + offset]
	ldq:
		opcode:
		parameters:
			in instruction memory: 
				byte dest: a number between 0-256 which specify which register will keep the result of the operation 
				byte src: a number between 0-256 which specify which register holds the the pointer to memory
				quad byte offset
		modifies: 
			registers: reg(dest)
		notes: 
			load quad byte from memory
			reg(dest) = (uint32_t)[reg(src) + offset]
	mov:
		opcode:
		parameters:
			in instruction memory:
				byte a: a number between 0-256 which specify which register will store the result of the operation
				byte b: a number between 0-256 which specify which register is the paramater of the operation
		modifies: 
			registers:
				reg(a)
		notes:
			the instruction MOVe the value of register b to register a
			reg(a) = reg(b)
	set:
		opcode:
		parameters:
			in instruction memory:
				byte r: a number between 0-256 which specify which register will store the result of the operation
				quad byte val: the value that register r will contain after this instruction
		modifies: 
			registers:
				reg(r)
		notes:
			the instruction SETs register r with the constant operand val
			reg(r) = val
	swap:
		opcode:
		parameters:
			in instruction memory:
				registers: byte a, b: numbers between 0-256 which specify which registers will swap values
		modifies: 
			registers:
				reg(a)
				reg(b)
		notes:
			the instruction SWAP the values of registers a and b
	push:
		parameters:
			in instruction memory:
				byte r: a number between 0-256 which specify which register will be pushed into the stack
		modifies: 
			registers: 
				sp
			memory: 
				[sp]
		notes:
			the instruction pushes register r to the stack
			sp = sp - 4
			[sp] = r
	pop:
		parameters:
			in instruction memory:
				byte r: a number between 0-256 which specify which register will be poped into from the stack
		modifies: 
			registers: 
				sp
				reg(r)
		notes:
			the instruction pop to register r from the stack
			reg(r) = [sp]
			sp = sp + 4
	jmpa:
		parameters:
			in instruction memory: 
				quad byte x
		modifies: 
			registers:
				ip
		notes:
			the instruction does an absoulte jump, its sets the value of ip register to x.
			if(CB)
			{
				ip = x
			}
	jmpr:
		parameters:
			in istruction memory: 
				byte r:  a number between 0-256 which specify which register this will use
		modifies: 
			registers: 
				ip
		notes:
			the instruction does an absolute jump, its sets the value of ip register to the value of the r regsiter.
			if(CB)
			{
				ip = reg(r)
			}
	call:
		parameters:
			in instruction memory:
				quad byte x
		modifies: 
			memory:
				[sp - 4]
			registers: 
				sp
				ip
		notes:
			the instruction push the ip register to the stack and then change the ip register value to x
			its the same like doing: (if assuming the CB is true)
				push ip
				jmpa x
	callr:
		parameters:
			in instruction memory: 
				byte r: a number between 0-256 which specify which register this will use
		modifies: 
			memory:
				[sp - 4]
			registers: 
				sp
				ip
		notes:
			the instruction push the ip register to the stack and then change the ip register value to that is in regsiter r
			its the same like doing: (if assuming CB is true)
				push ip
				jmpr r
	ret:
		parameters:
			in instruction memory:
				double byte x: determines how many bytes will be deallocated from the stack
		modifies: 
			registers: ip, sp
		notes:
			the instruction pop to the ip register from the stack, and then releases x bytes from the stack.
			same as doing:
				pop ip
				sp = sp + x
	
	shr:
		parameters:
			in instruction memory:
				byte dest: a number between 0-256 which specify which register will be shifted, and that regsiters will also contain the result
				byte times: a number between 0-256 which specify which register deteimnes how many times to shift
		modifies:
			register:
				reg(dest)
		notes:
			shift right register dest reg(times) times
			reg(dest) = reg(dest) << reg(times)
	shl:
		parameters:
			in instruction memory:
				byte dest: a number between 0-256 which specify which register will be shifted, and that regsiters will also contain the result
				byte times: a number between 0-256 which specify which register deteimnes how many times to shift
		modifies:
			register:
				reg(dest)
		notes:
			shift right register dest reg(times) times
			reg(dest) = reg(dest) >> reg(times)
	ror:
		parameters:
			in instruction memory:
				byte dest: a number between 0-256 which specify which register will be shifted, and that regsiters will also contain the result
				byte times: a number between 0-256 which specify which register deteimnes how many times to rotate
		modifies:
			register:
				reg(dest)
		notes:
			rotate right register dest reg(times) times
	rol:
		parameters:
			in instruction memory:
				byte dest: a number between 0-256 which specify which register will be shifted, and that regsiters will also contain the result
				byte times: a number between 0-256 which specify which register deteimnes how many times to rotate
		modifies:
			register:
				reg(dest)
		notes:
			rotate left register dest reg(times) times
	setbit:
		parameters:
			in instruction memory:
				byte dest: a number between 0-256 which specify which register will have the bit at index setted
				byte src: a number between 0-256 which specify which register will be the paramater of this operation
				byte index: the index of the bit
		modifies:
			reg(dest)
		notes:
			if dest != 0, set the bit at index inside the register dest to true, else set it to false
		
			if(src)
			{
				dest[index] = 1;
			}
			else
			{
				dest[index] = 0;
			}
	cc:
		handles conditionals
		this one will be further expolred in another part of the documentation
	save:
		notes:
			push all the registers into the stack
	rest:
		notes:
			does the oppsite of the `save` instruction and pop all the registers from the stack
	int:
		notes: 
			interrupt
	in:
		notes:
			input a value from one of the processor ports
	out:
		notes:
			output a value to one of the processor ports