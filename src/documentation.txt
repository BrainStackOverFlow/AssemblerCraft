documentation:

the registers are in the size of 32 bits

processor core:
	registers:
		res1:
			also known as 'r0'.
			will strore the results of instructions
		res2:
			also known as 'r1'.
			will strore the secondary results of instructions
		src1:
			also known as 'r2'.
			will strore the operand needed for instructions
		src2
			also known as 'r3'.
			will strore the secondary operand needed for instructions
		dr1
		dr2
		dr3
		dr4:
			they are the data registers, they are storing data also known as r4-7
		sp:
			the stack register, also known as 'r8'
			points to the top of the stack
		bp:
			the stack base register, also known as 'r9'
		flags:
			the flags register, also known as 'r10'
			contain the flollowing flags:	
		ip:
			the instruction pointer register, also known as 'r11'
			contain the pointer for the next instruction that will be executed

instruction:
	add:
		src1 and src2 will contain the integer numbers that will be added.
		res1 will contain the result
	sub:
		src1 and src2 will contain the integer numbers that will be substracted.
		res1 will contain the result
	umul
		Unsigned integer multiply src1 with src2
		the least signficant result (first 32 bits) is in res1.
		the most signficant result (last 32 bits) is in res2.
	udiv:
		Unsigned integer division. devides src1 with src2
		the result is in res1
		the reminder is in re2
	smul:
		signed integer division. multiply src1 with src2
		the least signficant result (first 32 bits) is in res1.
		the most signficant result (last 32 bits) is in res2.
	sdiv:
		signed integer division. devides src1 with src2
		the result is in res1
		the reminder is in re2
	neg:
		make the number negative of himself
		if integer was n its now -n
		src1 is intger to make negative
		res1 has the result number
		
	fadd:
		src1 and src2 will contain the float numbers that will be added.
		res1 will contain the result
	fsub:
		src1 and src2 will contain the float numbers that will be substracted.
		res1 will contain the result
	fmul:
		float multiplication:
		src1 and src2 will have the values that will be multiplied
		res1 have the result
	fdiv:
		float division:
		src1 and src2 will have the values that will be divised
		res1 have the result
	fpow:
		does Exponentiation. res1 = src1 ^ src2 (the base is src1 and the exponent is src2)
	frot:
	
	itf:
		convert integer to float:
		src1 will contain the integer
		res1 will contain the float
	fti:
		convert float to integer:
		src1 will contain the float
		res1 will contain the integer
	
	not:
		does a 'not' binary operation on the src1 register
		result in res1
	or:
		does a 'or' binary operation on the src1, src2 registers
		result on res1
	and:
		does a 'and' binary operation on the src1, src2 registers
		result on res1
	xor:
		does a 'xor' binary operation on the src1, src2 registers
		result on res1
	
	loadmb:
		load to memory byte
		src1 is the pointer to memory
		src2 is the value that would be uploaded
	loadmd:
		load to memory double byte (2 bytes, 16 bits)
		src1 is the pointer to memory
		src2 is the value that would be uploaded
	loadmq:
		load to memory double byte (4 bytes, 32 bits)
		src1 is the pointer to memory
		src2 is the value that would be uploaded
	loadr:
		load from memory to register
		src1 pointer to memory
		res1 have 4 bytes value from that pointer
		if u want only part of the values u can `and` the with the result
	mov:
		move values from registers to another registers
		in memory, after the opcode comes another 2 bytes that are related to this command, these are the operand
		the first operand states the destination register, and the second states the source register
	set:
		sets registers with a constant operand
		have extra 5 bytes after it.
		the first byte states what register will be set
		and the other 2-5 bytes (4) states the value that the register will be setted to.
	swap:
		swap registers values
		have 2 extra bytes that determines the swapped registers
	
	push:
		pushes a register to the stack
		the register is determined by the next byte
	pop:
		pop a register from the stack
		the register is determined by the next byte
		
	save:
		pushes all the registers to the stack to save them
	rest:
		pop all the registers from the stack to restore them
	
	jmp:
		
	call:
		pushes the ip regsiter to the stack, and then does the jmp instruction
	ret:
		pop to the ip register from the stack
	int:
		interrupt
	
	in:
		src1 is the input port
		res1 will have the value from the port
	out:
		src1 is the output port
		src2 is the value
		
	cpuid:
		